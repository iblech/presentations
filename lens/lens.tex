\documentclass{beamer}

\mode<presentation> {

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}

%\setbeameroption{show notes} % Kommentare im fertigen PDF

\usepackage[outputdir=output]{minted} % Syntax-Highlighted Code; requires pygments to be installed
\newminted{haskell}{}
\newmintinline{haskell}{}

\usepackage{hyperref}
\usepackage{tikz}

\definecolor{dimgray}{rgb}{0.41, 0.41, 0.41}

\usetheme{Boadilla}
\usecolortheme{seagull}

\setbeamertemplate{footline}[page number] % Einfacher Folienzähler als Fußzeile
\setbeamertemplate{navigation symbols}{} % Keine Navigationslinks
}

% Bildquelle: http://www.dibujosdisneyparacolorear.com/imagenes-donald-detective-jpg
\setbeamertemplate{background}{\includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio]{donald-detective-bg.jpg}}

\defbeamertemplate*{title page}{customized}[1][]
{
  \centering
  \usebeamerfont{title}{\LARGE \inserttitle}\par
  \usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par
  \bigskip
  \usebeamercolor[fg]{titlegraphic}\inserttitlegraphic\par
  \bigskip
  \usebeamerfont{author}\insertauthor\\[0.5em]
  \usebeamerfont{institute}\insertinstitute\par
  \usebeamerfont{date}\insertdate\par
}

\title[Lens]{Lenses und Zauberwürfel}
\titlegraphic{\includegraphics[width=0.65\linewidth]{rubiks-sequence.png}}
\author{Tim Baumann}
\institute[CCA]{Curry Club Augsburg}
\date{13. August 2015}

\newcommand{\kreuz}{$\,^\dag$} % Dagger, alter!
\newcommand{\kkreuz}{$\,^\ddag$} % DDagger, alter!
\newcommand{\fa}{$\forall$}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\iffalse
\begin{frame}
  \frametitle{Übersicht}
  \tableofcontents
\end{frame}
\fi

\begin{frame}[fragile,t]
  \frametitle{Welche Bibliothek?}
  % Bildquelle: https://ro-che.info/ccc/23
  \begin{figure}
    \includegraphics[width=0.9\linewidth]{ccc-picking-lens-library.png}
    \caption{Picking a Lens Library (Cartesian Closed Comic)}
  \end{figure}
  \begin{visibleenv}<2->
    \begin{center}
      \begin{minipage}{0.65\textwidth}
        Die von Edward Kmett natürlich! %Und nun alle:

        \visible<3->{\mintinline{bash}{$ cabal update}} \\
        \visible<4->{\mintinline{bash}{$ cabal install lens}} \\
        \visible<5->{\mintinline{bash}{Building profunctors...}} \\
        \visible<6->{\mintinline{bash}{Configuring semigroupoids...}} \\
        \visible<7->{\mintinline{bash}{Downloading kan-extensions...}}
      \end{minipage}
    \end{center}
  \end{visibleenv}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Was sind Lenses?}
  Eine Lens beschreibt eine (feste) Position in einer Datenstruktur, an der ein Wert eines bestimmten Typs gespeichert ist.
  Mit einer Lens ist es möglich, diesen Wert auszulesen und zu überschreiben.
  \begin{columns}[t]
    \column{.45\textwidth}
    \begin{visibleenv}<2->
\begin{haskellcode*}{fontsize=\small}
data Address = Address
  { _streetLine :: String
  , _townLine :: String
  }

data Person = Person
  { _firstName :: String
  , _lastName :: String
  , _address :: Address
  }
\end{haskellcode*}
    \end{visibleenv}
    \vspace{1em}
    \column{.5\textwidth}
    \begin{visibleenv}<3->
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
data Lens|\kreuz| s a = Lens|\kreuz|
  { getter :: s -> a
  , setter :: a -> s -> s
  }
\end{haskellcode*}
    \end{visibleenv}
    \begin{onlyenv}<4>
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
address :: Lens|\kreuz| Person Address
address = Lens|\kreuz|
  { getter = _address
  , setter = \a p ->
      p { _address = a }
  }
\end{haskellcode*}
    \end{onlyenv}
    \begin{onlyenv}<5->
      Lens-Gesetze:
      \begin{enumerate}
        \small
        \item \haskellinline{a = getter l (setter l a s)}
        \item \haskellinline{  setter l a . setter l b} \\
        \haskellinline{= setter l a}
        \item \haskellinline{s = setter l (getter l s) s}
      \end{enumerate}
      \note{Das sind die ``costate comonad coalgebra'' Gesetze}
    \end{onlyenv}
  \end{columns}
\begin{onlyenv}<4>
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
 streetLine, townLine :: Lens|\kreuz| Address String
 firstName,  lastName :: Lens|\kreuz| Person String
\end{haskellcode*}
\end{onlyenv}
\begin{onlyenv}<5->
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
 streetLine, townLine :: Lens|\kreuz| Address String
 firstName,  lastName :: Lens|\kreuz| Person String
 address              :: Lens|\kreuz| Person Address
\end{haskellcode*}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Komponieren von Lenses}
\begin{haskellcode*}{escapeinside=||}
compose :: Lens|\kreuz| s a -> Lens|\kreuz| a b -> Lens|\kreuz| s b
\end{haskellcode*}
  \vspace{-12pt}
  \begin{visibleenv}<2->
\begin{haskellcode*}{escapeinside=||}
compose l m = Lens|\kreuz|
  { getter = getter m . getter l
  , setter = \b s -> setter l (setter m b (getter l s)) s
  }
\end{haskellcode*}
  \end{visibleenv}
\begin{haskellcode*}{escapeinside=||}
personTownLine :: Lens|\kreuz| Person String
personTownLine = compose address townLine
\end{haskellcode*}

\vspace{1em}

  \begin{visibleenv}<3->
    Folgende Hilfsfunktion ist oft nützlich:
\begin{haskellcode*}{escapeinside=||}
modify :: Lens|\kreuz| s a -> (a -> a) -> s -> s
modify l f s = setter l (f (getter l s)) s
\end{haskellcode*}
    Zum Beispiel, um die Stadt in der Adresse in Versalien zu schreiben:
\begin{haskellcode*}{escapeinside=||}
person' = modify personTownLine (map toUpper) person
\end{haskellcode*}
  \end{visibleenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Alles wunderbar? Leider nein}

  \textbf{Problem Nr. 1}: Bei der Auswertung
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
  modify (compose l m) f s
= setter (compose l m) (f (getter (compose l m) s)) s
= setter l (setter m (f (getter m (getter l s))) (getter l s)) s
\end{haskellcode*}
  wird \haskellinline{getter l s} zweimal berechnet.
  Besser wäre
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
  modify (compose l m) f s
= let a = getter l s in setter l (setter m (f (getter m a)) a) s
\end{haskellcode*}

  \begin{visibleenv}<2->
    \begin{columns}[t]
      \column{.43\textwidth}

      \textbf{Problem Nr. 2}: In \haskellinline{modify} wird die Datenstruktur zweimal durchlaufen: Einmal, um den gesuchten Wert zu extrahieren, dann nochmal, um den neuen Wert abzulegen. \\
      Das kann kostspielig sein, z.\,B. bei der Lens rechts.
      \column{.5\textwidth}
\begin{haskellcode*}{fontsize=\footnotesize, escapeinside=??}
data NonEmpty a =
  Cons a (NonEmpty a) | Last a
last :: Lens?\kreuz? (NonEmpty a) a
last = Lens?\kreuz? getter setter
 where
  getter (Cons _ xs) = getter xs
  getter (Last x) = x
  setter a (Cons _ xs) = setter a xs
  setter a (Last _) = Last a
\end{haskellcode*}
    \end{columns}
  \end{visibleenv}
\end{frame}

\begin{frame}[fragile,t]
  \frametitle{Alles wunderbar? Leider nein}
  \textbf{Idee}: Erweitere die Definition einer Lens um die \haskellinline{modify}-Funktion. \\
  \begin{visibleenv}<2->
    Wir verallgemeinern auch gleich \haskellinline{modify} auf effektvolle Updatefunktionen, d.\,h. solche, die beispielsweise \haskellinline{IO} verwenden:
  \end{visibleenv}
  \begin{onlyenv}<1>
\begin{haskellcode*}{escapeinside=||}
data Lens|\kkreuz| s a = Lens|\kkreuz|
  { getter  :: s -> a
  , setter  :: a -> s -> s
  , modify  ::                   (a ->   a) -> s ->   s
  }
\end{haskellcode*}
  \end{onlyenv}
  \begin{onlyenv}<2-3>
\begin{haskellcode*}{escapeinside=||}
data Lens|\kkreuz| s a = Lens|\kkreuz|
  { getter  :: s -> a
  , setter  :: a -> s -> s
  , modifyF :: |\fa| f. Functor f => (a -> f a) -> s -> f s
  }
\end{haskellcode*}
  \end{onlyenv}
  \begin{onlyenv}<4->
\begin{haskellcode*}{escapeinside=||}
data Lens|\kkreuz| s a = Lens|\kkreuz|
  { {-getter  :: s -> a
  , setter  :: a -> s -> s
  ,-} modifyF :: |\fa| f. Functor f => (a -> f a) -> s -> f s
  }
\end{haskellcode*}
  \end{onlyenv}

  \vspace{2em}

  \begin{onlyenv}<3->
    \Large Bahnbrechende Einsicht von Twaan van Laarhoven: \\

    \colorbox{yellow}{
      \huge \haskellinline{modifyF} umfasst \haskellinline{getter} und \haskellinline{setter}!
    }
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{
    \colorbox{yellow}{
      \haskellinline{modifyF} umfasst
      \visible<2->{{\small 1.}} \haskellinline{getter} und
      \visible<3->{{\small 2.}} \haskellinline{setter}
    }
  }

\begin{haskellcode*}{escapeinside=||}
type Lens' s a = |\fa| f. Functor f => (a -> f a) -> s -> f s
\end{haskellcode*}

  \begin{enumerate}
    \item
    \begin{visibleenv}<2->
\begin{haskellcode}
(.^) :: s -> Lens' s a -> a
\end{haskellcode}
    \end{visibleenv}
    \vspace{-0.8em}
    \begin{visibleenv}<7->
\begin{haskellcode}
s .^ l = getConst (l Const s)
\end{haskellcode}
    \end{visibleenv}

    \begin{visibleenv}<6->
\begin{haskellcode}
newtype Const a b = Const { getConst :: a }
instance Functor (Const a) where
  fmap _ (Const b) = Const b
\end{haskellcode}
    \end{visibleenv}
    \vspace{1em}

    \item
    \begin{visibleenv}<3->
\begin{haskellcode}
(.~) :: Lens' s a -> a -> s -> s
\end{haskellcode}
    \end{visibleenv}
    \vspace{-0.8em}
    \begin{visibleenv}<5->
\begin{haskellcode}
(.~) l a s = getId (l (\_ -> Id a) s)
\end{haskellcode}
    \end{visibleenv}

    \begin{visibleenv}<4->
\begin{haskellcode}
newtype Id a = Id { getId :: a }
instance Functor Id where
  fmap f (Id a) = Id (f a)
\end{haskellcode}
    \end{visibleenv}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Komponieren von \haskellinline{Lens'}es}
  \begin{onlyenv}<1>
    \begin{tabular}{r l}
      Gegeben: & \haskellinline{ l  :: Lens' s a} \\
      und & \haskellinline{ m  :: Lens' a b} \\[0.4em]
      Gesucht: & \haskellinline{ ?  :: Lens' s b}
    \end{tabular}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{tabular}{r l}
      Gegeben: & \haskellinline[escapeinside=||]{ l  :: |\fa| f. Functor f => (a -> f a) ->  s -> f s} \\
      und & \haskellinline[escapeinside=||]{ m  :: |\fa| f. Functor f => (b -> f b) ->  a -> f a} \\[0.4em]
      Gesucht: & \haskellinline[escapeinside=||]{ ?  :: |\fa| f. Functor f => (b -> f b) ->  s -> f s}
    \end{tabular}
  \end{onlyenv}
  \begin{onlyenv}<3>
    \begin{tabular}{r l}
      Gegeben: & \haskellinline[escapeinside=||]{ l  :: |\fa| f. Functor f => (a -> f a) -> (s -> f s)} \\
      und & \haskellinline[escapeinside=||]{ m  :: |\fa| f. Functor f => (b -> f b) -> (a -> f a)} \\[0.4em]
      Gesucht: & \haskellinline[escapeinside=||]{ ?  :: |\fa| f. Functor f => (b -> f b) -> (s -> f s)}
    \end{tabular}
  \end{onlyenv}
  \begin{onlyenv}<4->
    \begin{tabular}{r l}
      Gegeben: & \haskellinline[escapeinside=||]{ l  :: |\fa| f. Functor f => (a -> f a) -> (s -> f s)} \\
      und & \haskellinline[escapeinside=||]{ m  :: |\fa| f. Functor f => (b -> f b) -> (a -> f a)} \\[0.4em]
      Gesucht: & \verb|l.m|\haskellinline[escapeinside=||]{ :: |\fa| f. Functor f => (b -> f b) -> (s -> f s)}
    \end{tabular}
  \end{onlyenv}

  \begin{visibleenv}<5->
    \vspace{1em}
    Dabei ist \verb|.| die stinknormale Funktionsverkettung aus der \verb|Prelude|!
    \vspace{1em}
  \end{visibleenv}

  \begin{visibleenv}<6->
    Im Beispiel vom Anfang:
\begin{haskellcode}
address :: Lens' Person Address
address f (Person first last addr) =
  fmap (Person first last) (f addr)
\end{haskellcode}
  \end{visibleenv}
  \begin{visibleenv}<7->
\begin{haskellcode}
streetLine, townLine :: Lens' Address String
firstName,  lastName :: Lens' Person String
\end{haskellcode}
  \end{visibleenv}
  \begin{visibleenv}<8->
    Dann haben wir \enspace
    \haskellinline{address.townLine :: Lens' Person String}
  \end{visibleenv}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Weitere optische Gerätschaften aus \haskellinline{lens}}
  \begin{center}
    \begin{tikzpicture}[
        overlay,
        myrect/.style={
          rectangle,
          draw,
          rounded corners,
          inner sep=4pt
        }
      ]
      \begin{scope}[shift={(1,0)}]
        %\draw[use as bounding box] (-5,-1) rectangle (2.5,1.5);
        \node<7->[myrect] (setter) at (-4,0.5) {Setter};
        \node<6->[myrect] (fold) at (-4,-0.5) {Fold};
        \node<2->[myrect] (traversal) at (-2,0.5) {Traversal};
        \node<5->[myrect] (getter) at (-2,-0.5) {Getter};
        \node<3->[myrect] (prism) at (0,0.5) {Prism};
        \node[myrect] (lens) at (0,-0.5) {Lens};
        \node<4->[myrect] (iso) at (1.5,0) {Iso};
        \draw<7->[->] (setter) -- (traversal);
        \draw<6->[->] (fold) -- (traversal);
        \draw<6->[->] (fold) -- (getter);
        \draw<2->[->] (traversal) -- (lens);
        \draw<3->[->] (traversal) -- (prism);
        \draw<5->[->] (getter) -- (lens);
        \draw<4->[->] (prism) -- (iso);
        \draw<4->[->] (lens) -- (iso);
      \end{scope}
    \end{tikzpicture}
  \end{center}

  \vspace{2em}

  %{\setlength\tabcolsep{0.2em}
  %\footnotesize

  {
  \setbeamercolor{alerted text}{fg=orange}
  \setbeamerfont{alerted text}{series=\mdseries}

  \begin{onlyenv}<1-7>
    \begin{tabular}{r l}
      \visible<7->{\alert<7>{Setter}} &
      \visible<7->{in \haskellinline{s} gibt es veränderbare \haskellinline{a}'s} \\

      \visible<6->{\alert<6>{Fold}} &
      \visible<6->{Funktion \haskellinline{s -> [a]}} \\

      \visible<5->{\alert<5>{Getter}} &
      \visible<5->{Funktion \haskellinline{s -> a}} \\

      \visible<2->{\alert<2>{Traversal}} &
      \visible<2->{ein \haskellinline{s} besteht aus \haskellinline{a}'s und anderen Daten} \\

      \alert<1>{Lens} &
      ein \haskellinline{s} besteht aus einem \haskellinline{a} und anderen Daten \\

      \visible<3->{\alert<3>{Prism}} &
      \visible<3->{ein \haskellinline{s} ist ein \haskellinline{a} oder etwas anderes} \\

      \visible<4->{\alert<4>{Iso}} &
      \visible<4->{ein \haskellinline{s} ist dasselbe wie ein \haskellinline{a}}
    \end{tabular}
  \end{onlyenv}}

  \begin{onlyenv}<8->
    \vspace{-0.7em}
\begin{haskellcode*}{fontsize=\footnotesize,baselinestretch=1.2}
   Setter' s a =                                (a -> Id a) -> s -> Id s
     Fold  s a = (Contrav't f, Applicative f) => (a -> f a) -> s -> f s
   Getter  s a =     (Contrav't f, Functor f) => (a -> f a) -> s -> f s
Traversal' s a =               Applicative f  => (a -> f a) -> s -> f s
     Lens' s a =                   Functor f  => (a -> f a) -> s -> f s
    Prism' s a =    (Choice p, Applicative f) =>  p a (f a) -> p s (f s)
      Iso' s a =    (Profunctor p, Functor f) =>  p a (f a) -> p s (f s)
\end{haskellcode*}
  \end{onlyenv}

  % Lens-Beispiele
  \begin{onlyenv}<1>
\begin{haskellcode*}{fontsize=\small}
lens :: (s -> a) -> (s -> a -> s) -> Lens' s a
_1 :: Lens' (x,y) x     _1 :: Lens' (x,y,z) x
_2 :: Lens' (x,y) y     _2 :: Lens' (x,y,z) y
choosing :: Lens' s a -> Lens' s' a -> Lens' (Either s s') a
inside :: Lens' s a -> Lens' (e -> s) (e -> a)
devoid :: Lens' Void a    united :: Lens' a ()
\end{haskellcode*}
  % -- Void = (a, Void)
  % -- a    = (a, ())
  \end{onlyenv}

  % Traversal-Beispiele
  \begin{onlyenv}<2>
\begin{haskellcode*}{fontsize=\small}
traverse :: Traversable t => Traversal' (t a) a
beside :: Traversal' s a -> Traversal s' a b
       -> Traversal' (s,s') a
taking :: Int -> Traversal' s a -> Traversal' s a
\end{haskellcode*}
  \end{onlyenv}

  % Prism-Beispiele
  \begin{onlyenv}<3>
\begin{haskellcode*}{fontsize=\small}
prism :: (a -> s) -> (s -> Either s a) -> Prism' s a
_Left :: Prism' (Either a c) a    _Right :: Prism' (Either a c) c
_Just :: Prism' (Maybe a) a
_Void :: Prism' s Void
outside :: Prism' s a -> Lens' (s -> r) (a -> r)
\end{haskellcode*}
  \end{onlyenv}

  % Iso-Beispiele
  \begin{onlyenv}<4>
\begin{haskellcode}
iso :: (s -> a) -> (a -> s) -> Iso' s a
curried :: Iso' ((a, b) -> c) (a -> b -> c)
from :: Iso' s a -> Iso' a s
mapping :: Functor f => Iso' s a -> Iso' (f s) (f a)
\end{haskellcode}
  \end{onlyenv}

  % Getter-Beispiele
  \begin{onlyenv}<5>
\begin{haskellcode}
to :: (s -> a) -> Getter s a
to length :: Getter [a] Int
\end{haskellcode}
  \end{onlyenv}

  % Fold-Beispiele
  \begin{onlyenv}<6>
\begin{haskellcode}
unfolded :: (b -> Maybe (a, b)) -> Fold b a
folding :: Foldable f => (s -> f a) -> Fold s a
folded  :: Foldable f => Fold (f a) a
replicated :: Int -> Fold a a
\end{haskellcode}
  \end{onlyenv}

  % Setter-Beispiele
  \begin{onlyenv}<7>
\begin{haskellcode}
sets :: ((a -> a) -> s -> s) -> Setter' s a
mapped :: Functor f => Setter' (f a) a
mapped :: Setter' (x -> a) a
\end{haskellcode}
  \end{onlyenv}

  {\small
  \begin{onlyenv}<9->
    \begin{itemize}
      \item<9-> Durch Subtyping ist jeder Iso eine Lens, jedes Prism ein Traversal \ldots
      \item<10-> Man kann z.\,B. eine Lens mit einem Traversal verknüpfen (mit \haskellinline{.}) und man bekommt ein Traversal.
      \item<11-> Viele Beispielfunktionen haben einen allgemeineren Typ als angegeben.
    \end{itemize}
  \end{onlyenv}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API}
\begin{haskellcode}
(.^) :: s -> Lens s a -> a
\end{haskellcode}
\end{frame}

\begin{frame}
  \frametitle{Beispiel: Curry-Feed parsen}
  \begin{center}
    \includegraphics[width=10cm]{curry-termine-screenshot.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Beispiel: Curry-Feed parsen}
  \inputminted[fontsize=\footnotesize]{xml}{curry-feed.xml}
\end{frame}

{\setbeamertemplate{background}{}
\begin{frame}[b]
  \frametitle{Beispiel: Curry-Feed parsen}
  \begin{visibleenv}<2->
    \hfill \includegraphics[height=2cm]{lens-jquery.png}
  \end{visibleenv}
  \vspace{-2cm}
  \inputminted[fontsize=\small]{haskell}{curry-termine/Main.hs}
\end{frame}}

\begin{frame}[fragile,t]
  \frametitle{Wie bekomme ich Lenses für meine Datentypen?}
  \begin{columns}[t]
    \column{0.48\textwidth}
    \begin{onlyenv}<1-2>
      \begin{visibleenv}<2>
\begin{haskellcode*}{stripnl=false,fontsize=\small}

-- keine Imports nötig

\end{haskellcode*}
      \end{visibleenv}
    \end{onlyenv}
    \begin{onlyenv}<3>
\begin{haskellcode*}{stripnl=false,fontsize=\small}
{-# LANGUAGE TemplateHaskell #-}
import Control.Lens.TH

\end{haskellcode*}
    \end{onlyenv}
    \begin{onlyenv}<4>
\begin{haskellcode*}{stripnl=false,fontsize=\small}
{-# LANGUAGE TemplateHaskell #-}
import Lens.Micro.TH
-- aus 'microlens-th' (Beispiel)
\end{haskellcode*}
    \end{onlyenv}
\begin{haskellcode*}{fontsize=\small}
data Address = Address {...}

data Person = Person
  { _firstName :: String
  , _lastName :: String
  , _address :: Address
  }
\end{haskellcode*}
    \begin{onlyenv}<2>
\begin{haskellcode*}{fontsize=\small}
address :: Functor f
        => (Address -> f Address)
        -> Person -> f Person
address f (Person first last addr) =
  fmap (Person first last) (f addr)

-- und so weiter ...
\end{haskellcode*}
    \end{onlyenv}
    \begin{onlyenv}<3-4>
\begin{haskellcode*}{fontsize=\small}
makeLenses'' Address
makeLenses'' Person
\end{haskellcode*}
    \end{onlyenv}

    \column{.52\textwidth}
    %Drei Optionen:
    \begin{enumerate}
      \item<2-> Lenses selber schreiben \\[0.2em]
      {\small \color{dimgray}
      Vorteil: Keine Library benötigt! \\
      Nachteil: Boilerplate-Code}
      \item<3-> Lenses generieren mit Template Haskell-Funktionen aus \haskellinline{lens} \\[0.2em]
      {\small \color{dimgray}
      Vorteil: Komfortabel \\
      Nachteil: Template Haskell}
      \item<4-> Lenses generieren mit einer anderen Bibliothek und TH \\[0.2em]
      {\small \color{dimgray}
      Vorteil: Komfortabel, keine Dependency auf \verb|lens| \\
      Nachteil: Template Haskell}
    \end{enumerate}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Beispiel: Imperative Programmierung}
\end{frame}

\begin{frame}[fragile,t]
  \frametitle{Wo kann ich mehr über \haskellinline{lens} erfahren?}
  \begin{itemize}
    \item Das Lens-Wiki: \url{https://github.com/ekmett/lens/wiki}
    \item Blogserie ``Lens over Tea'' \url{http://artyom.me/lens-over-tea-1}
    \item \href{https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation}{Vortrag von Simon Peyton Jones bei Skills Matter}
    \item \href{http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html}{Blogpost: ``Program imperatively using Haskell lenses''}
    \item \href{https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial}{School of Haskell: ``A Little Lens Starter Tutorial''}
    \item Cheat Sheet für \verb|Control.Lens|: \\
    \url{https://github.com/anchor/haskell-cheat-sheets}
  \end{itemize}
\end{frame}

{\setbeamertemplate{background}{}
\begin{frame}[b]
  \begin{center}
    \includegraphics[width=5cm,keepaspectratio]{donald-detective.jpg} \\
  \end{center}

  \centering \small
  \url{http://timbaumann.info/presentations/lens/lens.pdf} \\
  \url{https://github.com/timjb/presentations/tree/gh-pages/lens}
\end{frame}}

% TODO:
% Type-changing lenses
% * Traversals erklären
% * Rubiks-Cube-Beispiel
% Funktionen: over, both
% at :: Lens (Map a) (Maybe a)
% Was ist die Konvention mit "Of" am Ende des Namens einer Funktion?
% Die beste imperative Programmiersprache ist ... Haskell (+=, *=, ...)

\end{document}
