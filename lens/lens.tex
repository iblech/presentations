\documentclass{beamer}

\mode<presentation> {

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}

\usepackage[outputdir=output]{minted} % Syntax-Highlighted Code; requires pygments to be installed
\newminted{haskell}{}
\newmintinline{haskell}{}

\usepackage{tikz}

\usetheme{Boadilla}
\usecolortheme{seagull}

\setbeamertemplate{footline}[page number] % Einfacher Folienzähler als Fußzeile
\setbeamertemplate{navigation symbols}{} % Keine Navigationslinks
}

\defbeamertemplate*{title page}{customized}[1][]
{
  \centering
  \usebeamerfont{title}{\LARGE \inserttitle}\par
  \usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par
  \bigskip
  \usebeamercolor[fg]{titlegraphic}\inserttitlegraphic\par
  \bigskip
  \usebeamerfont{author}\insertauthor\\[0.5em]
  \usebeamerfont{institute}\insertinstitute\par
  \usebeamerfont{date}\insertdate\par
}

\title[Lens]{Lenses und Zauberwürfel}
\titlegraphic{\includegraphics[width=0.65\linewidth]{rubiks-sequence.png}}
\author{Tim Baumann}
\institute[CCA]{Curry Club Augsburg}
\date{13. August 2015}

\newcommand{\kreuz}{$\,^\dag$} % Dagger, alter!
\newcommand{\kkreuz}{$\,^\ddag$} % DDagger, alter!

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\iffalse
\begin{frame}
  \frametitle{Übersicht}
  \tableofcontents
\end{frame}
\fi

\begin{frame}[fragile,t]
  \frametitle{Welche Bibliothek?}
  % Bildquelle: https://ro-che.info/ccc/23
  \begin{figure}
    \includegraphics[width=0.9\linewidth]{ccc-picking-lens-library.png}
    \caption{Picking a Lens Library (Cartesian Closed Comic)}
  \end{figure}
  \begin{visibleenv}<2->
    \begin{center}
      \begin{minipage}{0.65\textwidth}
        Die von Edward Kmett natürlich! %Und nun alle:

        \visible<3->{\mintinline{bash}{$ cabal update}} \\
        \visible<4->{\mintinline{bash}{$ cabal install lens}} \\
        \visible<5->{\mintinline{bash}{Building profunctors...}} \\
        \visible<6->{\mintinline{bash}{Configuring semigroupoids...}} \\
        \visible<7->{\mintinline{bash}{Downloading kan-extensions...}}
      \end{minipage}
    \end{center}
  \end{visibleenv}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Was sind Lenses?}
  Eine Lens beschreibt eine (feste) Position in einer Datenstruktur, an der ein Wert eines bestimmten Typs gespeichert ist.
  Mit einer Lens ist es möglich, diesen Wert auszulesen und zu überschreiben.
  \begin{columns}[t]
    \column{.45\textwidth}
    \begin{visibleenv}<2->
\begin{haskellcode*}{fontsize=\small}
data Address = Address
  { _streetLine :: String
  , _townLine :: String
  }

data Person = Person
  { _firstName :: String
  , _lastName :: String
  , _address :: Address
  }
\end{haskellcode*}
    \end{visibleenv}
    \vspace{1em}
    \column{.5\textwidth}
    \begin{visibleenv}<3->
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
data Lens|\kreuz| s a = Lens|\kreuz|
  { getter :: s -> a
  , setter :: a -> s -> s
  }
\end{haskellcode*}
    \end{visibleenv}
    \begin{onlyenv}<4>
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
address :: Lens|\kreuz| Person Address
address = Lens|\kreuz|
  { getter = _address
  , setter = \a p ->
      p { _address = a }
  }
\end{haskellcode*}
    \end{onlyenv}
    \begin{onlyenv}<5->
      Lens-Gesetze:
      \begin{enumerate}
        \small
        \item \haskellinline{a = getter l (setter l a s)}
        \item \haskellinline{  setter l a . setter l b} \\
        \haskellinline{= setter l a}
        \item \haskellinline{s = setter l (getter l s) s}
      \end{enumerate}
    \end{onlyenv}
  \end{columns}
\begin{onlyenv}<4>
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
 streetLine, townLine :: Lens|\kreuz| Address String
 firstName,  lastName :: Lens|\kreuz| Person String
\end{haskellcode*}
\end{onlyenv}
\begin{onlyenv}<5->
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
 streetLine, townLine :: Lens|\kreuz| Address String
 firstName,  lastName :: Lens|\kreuz| Person String
 address              :: Lens|\kreuz| Person Address
\end{haskellcode*}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Komponieren von Lenses}
\begin{haskellcode*}{escapeinside=||}
compose :: Lens|\kreuz| s a -> Lens|\kreuz| a b -> Lens|\kreuz| s b
\end{haskellcode*}
  \vspace{-12pt}
  \begin{visibleenv}<2->
\begin{haskellcode*}{escapeinside=||}
compose l m = Lens|\kreuz|
  { getter = getter m . getter l
  , setter = \b s -> setter l (setter m b (getter l s)) s
  }
\end{haskellcode*}
  \end{visibleenv}
\begin{haskellcode*}{escapeinside=||}
personTownLine :: Lens|\kreuz| Person String
personTownLine = compose address townLine
\end{haskellcode*}

\vspace{1em}

  \begin{visibleenv}<3->
    Folgende Hilfsfunktion ist oft nützlich:
\begin{haskellcode*}{escapeinside=||}
modify :: Lens|\kreuz| s a -> (a -> a) -> s -> s
modify l f s = setter l (f (getter l s)) s
\end{haskellcode*}
    Zum Beispiel, um die Stadt in der Adresse in Versalien zu schreiben:
\begin{haskellcode*}{escapeinside=||}
person' = modify personTownLine (map toUpper) person
\end{haskellcode*}
  \end{visibleenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Alles wunderbar? Leider nein}

  \textbf{Problem Nr. 1}: Bei der Auswertung
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
  modify (compose l m) f s
= setter (compose l m) (f (getter (compose l m) s)) s
= setter l (setter m (f (getter m (getter l s))) (getter l s)) s
\end{haskellcode*}
  wird \haskellinline{getter l s} zweimal berechnet.
  Besser wäre
\begin{haskellcode*}{fontsize=\small, escapeinside=||}
  modify (compose l m) f s
= let a = getter l s in setter l (setter m (f (getter m a)) a) s
\end{haskellcode*}

  \begin{visibleenv}<2->
    \begin{columns}[t]
      \column{.43\textwidth}

      \textbf{Problem Nr. 2}: In \haskellinline{modify} wird die Datenstruktur zweimal durchlaufen: Einmal, um den gesuchten Wert zu extrahieren, dann nochmal, um den neuen Wert abzulegen. \\
      Das kann kostspielig sein, z.\,B. bei der Lens rechts.
      \column{.5\textwidth}
\begin{haskellcode*}{fontsize=\footnotesize, escapeinside=??}
data NonEmpty a =
  Cons a (NonEmpty a) | Last a
last :: Lens?\kreuz? (NonEmpty a) a
last = Lens?\kreuz? getter setter
 where
  getter (Cons _ xs) = getter xs
  getter (Last x) = x
  setter a (Cons _ xs) = setter a xs
  setter a (Last _) = Last a
\end{haskellcode*}
    \end{columns}
  \end{visibleenv}
\end{frame}

\begin{frame}[fragile,t]
  \frametitle{Alles wunderbar? Leider nein}
  \textbf{Idee}: Erweitere die Definition einer Lens um die \haskellinline{modify}-Funktion. \\
  \begin{visibleenv}<2->
    Wir verallgemeinern auch gleich \haskellinline{modify} auf effektvolle Updatefunktionen, d.\,h. solche, die beispielsweise \haskellinline{IO} verwenden:
  \end{visibleenv}
  \begin{onlyenv}<1>
\begin{haskellcode*}{escapeinside=||}
data Lens|\kkreuz| s a = Lens|\kkreuz|
  { getter  :: s -> a
  , setter  :: a -> s -> s
  , modify  ::              (a ->   a) -> s ->   s
  }
\end{haskellcode*}
  \end{onlyenv}
  \begin{onlyenv}<2-3>
\begin{haskellcode*}{escapeinside=||}
data Lens|\kkreuz| s a = Lens|\kkreuz|
  { getter  :: s -> a
  , setter  :: a -> s -> s
  , modifyF :: Functor f => (a -> f a) -> s -> f s
  }
\end{haskellcode*}
  \end{onlyenv}
  \begin{onlyenv}<4->
\begin{haskellcode*}{escapeinside=||}
data Lens|\kkreuz| s a = Lens|\kkreuz|
  { {-getter  :: s -> a
  , setter  :: a -> s -> s
  ,-} modifyF :: Functor f => (a -> f a) -> s -> f s
  }
\end{haskellcode*}
  \end{onlyenv}

  \vspace{2em}

  \begin{onlyenv}<3->
    \Large Bahnbrechende Einsicht von Twaan van Laarhoven: \\

    \colorbox{yellow}{
      \huge \haskellinline{modifyF} umfasst \haskellinline{getter} und \haskellinline{setter}!
    }
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]
  \frametitle{
    \colorbox{yellow}{
      \haskellinline{modifyF} umfasst
      \visible<2->{{\small 1.}} \haskellinline{getter} und
      \visible<3->{{\small 2.}} \haskellinline{setter}
    }
  }

\begin{haskellcode}
type Lens' s a = Functor f => (a -> f a) -> s -> f s
\end{haskellcode}

  \begin{enumerate}
    \item
    \begin{visibleenv}<2->
\begin{haskellcode}
(.^) :: s -> Lens' s a -> a
\end{haskellcode}
    \end{visibleenv}
    \vspace{-0.8em}
    \begin{visibleenv}<7->
\begin{haskellcode}
s .^ l = getConst (l Const s)
\end{haskellcode}
    \end{visibleenv}

    \begin{visibleenv}<6->
\begin{haskellcode}
newtype Const a b = Const { getConst :: a }
instance Functor (Const a) where
  fmap _ (Const b) = Const b
\end{haskellcode}
    \end{visibleenv}
    \vspace{1em}

    \item
    \begin{visibleenv}<3->
\begin{haskellcode}
(.~) :: Lens' s a -> a -> s -> s
\end{haskellcode}
    \end{visibleenv}
    \vspace{-0.8em}
    \begin{visibleenv}<5->
\begin{haskellcode}
(.~) l a s = getId (l (\_ -> Id s) s)
\end{haskellcode}
    \end{visibleenv}

    \begin{visibleenv}<4->
\begin{haskellcode}
newtype Id a = Id { getId :: a }
instance Functor Id where
  fmap f (Id a) = Id (f a)
\end{haskellcode}
    \end{visibleenv}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Komponieren von \haskellinline{Lens'}es}
  \begin{onlyenv}<1>
    \begin{tabular}{r l}
      Gegeben: & \mintinline{haskell}{ l  :: Lens' s a} \\
      und & \mintinline{haskell}{ m  :: Lens' a b} \\[0.4em]
      Gesucht: & \mintinline{haskell}{ ?  :: Lens' s b}
    \end{tabular}
  \end{onlyenv}
  \begin{onlyenv}<2>
    \begin{tabular}{r l}
      Gegeben: & \mintinline{haskell}{ l  :: Functor f => (a -> f a) ->  s -> f s} \\
      und & \mintinline{haskell}{ m  :: Functor f => (b -> f b) ->  a -> f a} \\[0.4em]
      Gesucht: & \mintinline{haskell}{ ?  :: Functor f => (b -> f b) ->  s -> f s}
    \end{tabular}
  \end{onlyenv}
  \begin{onlyenv}<3>
    \begin{tabular}{r l}
      Gegeben: & \mintinline{haskell}{ l  :: Functor f => (a -> f a) -> (s -> f s)} \\
      und & \mintinline{haskell}{ m  :: Functor f => (b -> f b) -> (a -> f a)} \\[0.4em]
      Gesucht: & \mintinline{haskell}{ ?  :: Functor f => (b -> f b) -> (s -> f s)}
    \end{tabular}
  \end{onlyenv}
  \begin{onlyenv}<4->
    \begin{tabular}{r l}
      Gegeben: & \mintinline{haskell}{ l  :: Functor f => (a -> f a) -> (s -> f s)} \\
      und & \mintinline{haskell}{ m  :: Functor f => (b -> f b) -> (a -> f a)} \\[0.4em]
      Gesucht: & \mintinline{haskell}{l.m :: Functor f => (b -> f b) -> (s -> f s)}
    \end{tabular}
  \end{onlyenv}

  \begin{visibleenv}<5->
    \vspace{1em}
    Dabei ist \haskellinline{.} die stinknormale Funktionsverkettung aus der \haskellinline{Prelude}!
    \vspace{1em}
  \end{visibleenv}

  \begin{visibleenv}<6->
    Im Beispiel vom Anfang:
\begin{haskellcode}
address :: Lens' Person Address
address f (Person first last addr) =
  fmap (Person first last) (f addr)
\end{haskellcode}
  \end{visibleenv}
  \begin{visibleenv}<7->
\begin{haskellcode}
streetLine, townLine :: Lens' Address String
firstName,  lastName :: Lens' Person String
\end{haskellcode}
  \end{visibleenv}
  \begin{visibleenv}<8->
    Dann haben wir \enspace
    \haskellinline{address.townLine :: Lens' Person String}
  \end{visibleenv}
\end{frame}

\begin{frame}[t,fragile]
  \frametitle{Weitere optische Gerätschaften aus \haskellinline{lens}}
  \begin{center}
    \begin{tikzpicture}[
        overlay,
        myrect/.style={
          rectangle,
          draw,
          rounded corners,
          inner sep=4pt
        }
      ]
      \begin{scope}[shift={(1,0)}]
        %\draw[use as bounding box] (-5,-1) rectangle (2.5,1.5);
        \node<7->[myrect] (setter) at (-4,0.5) {Setter};
        \node<6->[myrect] (fold) at (-4,-0.5) {Fold};
        \node<2->[myrect] (traversal) at (-2,0.5) {Traversal};
        \node<5->[myrect] (getter) at (-2,-0.5) {Getter};
        \node<3->[myrect] (prism) at (0,0.5) {Prism};
        \node[myrect] (lens) at (0,-0.5) {Lens};
        \node<4->[myrect] (iso) at (1.5,0) {Iso};
        \draw<7->[->] (setter) -- (traversal);
        \draw<6->[->] (fold) -- (traversal);
        \draw<6->[->] (fold) -- (getter);
        \draw<2->[->] (traversal) -- (lens);
        \draw<3->[->] (traversal) -- (prism);
        \draw<5->[->] (getter) -- (lens);
        \draw<4->[->] (prism) -- (iso);
        \draw<4->[->] (lens) -- (iso);
      \end{scope}
    \end{tikzpicture}
  \end{center}

  \vspace{2em}

  %{\setlength\tabcolsep{0.2em}
  %\footnotesize

  {
  \setbeamercolor{alerted text}{fg=orange}
  \setbeamerfont{alerted text}{series=\mdseries}

  \begin{onlyenv}<1-7>
    \begin{tabular}{r l}
      \visible<7->{\alert<7>{Setter}} &
      \visible<7->{in \haskellinline{s} gibt es veränderbare \haskellinline{a}'s} \\

      \visible<6->{\alert<6>{Fold}} &
      \visible<6->{Funktion \haskellinline{s -> [a]}} \\

      \visible<5->{\alert<5>{Getter}} &
      \visible<5->{Funktion \haskellinline{s -> a}} \\

      \visible<2->{\alert<2>{Traversal}} &
      \visible<2->{ein \haskellinline{s} besteht aus \haskellinline{a}'s und anderen Daten} \\

      \alert<1>{Lens} &
      ein \haskellinline{s} besteht aus einem \haskellinline{a} und anderen Daten \\

      \visible<3->{\alert<3>{Prism}} &
      \visible<3->{ein \haskellinline{s} ist ein \haskellinline{a} oder etwas anderes} \\

      \visible<4->{\alert<4>{Iso}} &
      \visible<4->{ein \haskellinline{s} ist dasselbe wie ein \haskellinline{a}}
    \end{tabular}
  \end{onlyenv}}

  \begin{onlyenv}<8->
    \vspace{-0.7em}
\begin{haskellcode*}{fontsize=\footnotesize,baselinestretch=1.2}
   Setter' s a =                                (a -> Id a) -> s -> Id s
     Fold  s a = (Contrav't f, Applicative f) => (a -> f a) -> s -> f s
   Getter  s a =     (Contrav't f, Functor f) => (a -> f a) -> s -> f s
Traversal' s a =               Applicative f  => (a -> f a) -> s -> f s
     Lens' s a =                   Functor f  => (a -> f a) -> s -> f s
    Prism' s a =    (Choice p, Applicative f) =>  p a (f a) -> p s (f s)
      Iso' s a =    (Profunctor p, Functor f) =>  p a (f a) -> p s (f s)
\end{haskellcode*}
  \end{onlyenv}

  % Lens-Beispiele
  \begin{onlyenv}<1>
\begin{haskellcode*}{fontsize=\small}
lens :: (s -> a) -> (s -> a -> s) -> Lens' s a
_1 :: Lens' (x,y) x     _1 :: Lens' (x,y,z) x
_2 :: Lens' (x,y) y     _2 :: Lens' (x,y,z) y
choosing :: Lens' s a -> Lens' s' a -> Lens' (Either s s') a
inside :: Lens' s a -> Lens' (e -> s) (e -> a)
devoid :: Lens' Void a    united :: Lens' a ()
\end{haskellcode*}
  % -- Void = (a, Void)
  % -- a    = (a, ())
  \end{onlyenv}

  % Traversal-Beispiele
  \begin{onlyenv}<2>
\begin{haskellcode*}{fontsize=\small}
traverse :: Traversable t => Traversal' (t a) a
beside :: Traversal' s a -> Traversal s' a b
       -> Traversal' (s,s') a
taking :: Int -> Traversal' s a -> Traversal' s a
\end{haskellcode*}
  \end{onlyenv}

  % Prism-Beispiele
  \begin{onlyenv}<3>
\begin{haskellcode*}{fontsize=\small}
prism :: (a -> s) -> (s -> Either s a) -> Prism' s a
_Left :: Prism' (Either a c) a    _Right :: Prism' (Either a c) c
_Just :: Prism' (Maybe a) a
_Void :: Prism' s Void
outside :: Prism' s a -> Lens' (s -> r) (a -> r)
\end{haskellcode*}
  \end{onlyenv}

  % Iso-Beispiele
  \begin{onlyenv}<4>
\begin{haskellcode}
iso :: (s -> a) -> (a -> s) -> Iso' s a
curried :: Iso' ((a, b) -> c) (a -> b -> c)
from :: Iso' s a -> Iso' a s
mapping :: Functor f => Iso' s a -> Iso' (f s) (f a)
\end{haskellcode}
  \end{onlyenv}

  % Getter-Beispiele
  \begin{onlyenv}<5>
\begin{haskellcode}
to :: (s -> a) -> Getter s a
to length :: Getter [a] Int
\end{haskellcode}
  \end{onlyenv}

  % Fold-Beispiele
  \begin{onlyenv}<6>
\begin{haskellcode}
unfolded :: (b -> Maybe (a, b)) -> Fold b a
folding :: Foldable f => (s -> f a) -> Fold s a
folded  :: Foldable f => Fold (f a) a
replicated :: Int -> Fold a a
\end{haskellcode}
  \end{onlyenv}

  % Setter-Beispiele
  \begin{onlyenv}<7>
\begin{haskellcode}
sets :: ((a -> a) -> s -> s) -> Setter' s a
mapped :: Functor f => Setter' (f a) a
mapped :: Setter' (x -> a) a
\end{haskellcode}
  \end{onlyenv}

  {\small
  \begin{onlyenv}<9->
    \begin{itemize}
      \item<9-> Durch Subtyping ist jeder Iso eine Lens, jedes Prism ein Traversal \ldots
      \item<10-> Man kann z.\,B. eine Lens mit einem Traversal verknüpfen (mit \haskellinline{.}) und man bekommt ein Traversal.
      \item<11-> Viele Beispielfunktionen haben einen allgemeineren Typ als angegeben.
    \end{itemize}
  \end{onlyenv}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API}
\begin{haskellcode}
(.^) :: s -> Lens s a -> a
\end{haskellcode}
\end{frame}

% TODO:
% * Traversals erklären
% * Rubiks-Cube-Beispiel
% * "jQuery für Haskell"

\end{document}
